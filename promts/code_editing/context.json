[
  {
    "user": "сделай выбор ветки коммандой (как всё остальное)",
    "assistant": "Для реализации выбора ветки с помощью команды, нужно внести изменения в код. Это предполагает:\n\n1. Добавление новой команды для выбора ветки.\n2. Изменение контекста текущей ветки при вызове команды.\n3. Возможность переключаться между ветками в ходе работы программы.\n\nВот как можно это сделать:\n\n---\n\n### Шаг 1: Добавить новую команду в `devolp_config.json`\n\nВ файле `devolp_config.json` добавьте команду для выбора ветки в секцию `\"commands\"`:\n\n```json\n\"selectBranchCommands\": [\"-branch\", \"-branches\", \"-select\", \"ветка\", \"выбери ветку\"]\n```\n\n---\n\n### Шаг 2: Обновить логику в `main.py`\n\nДобавьте обработку новой команды в основной цикл:\n\n```python\nfrom app.utils.content import load_context, save_context\n\ndef main(queue, outputText, commandToSound, condition):\n    current_branch = \"default\"  # Установим начальную ветку\n\n    while not condition.is_set():\n        req = requestInFile()\n        if queue.empty() and not req:\n            time.sleep(1)\n        else:\n            if req: \n                res = req\n            else:\n                res = queue.get()\n                wright(res)\n\n            try:\n                firstWord = res.split(' ', 1)[0]\n                for i in commands:\n                    if res in i:\n                        firstWord = i\n            except:\n                firstWord = None\n\n            if firstWord in allCommands or res in allCommands:\n                command = firstWord\n                argument = res.split(' ', 1)[1] if ' ' in res else None\n\n                # Логика выбора ветки\n                if command in commands['selectBranchCommands']:\n                    if argument:\n                        current_branch = argument\n                        wright(f\"Текущая ветка изменена на: {current_branch}\")\n                    else:\n                        wright(\"Ошибка: укажите имя ветки для переключения.\")\n\n                elif command in commands['clearContextCommands']:\n                    context_file = f\"promts/{current_branch}/context.json\"\n                    with open(context_file, 'w', encoding='utf-8') as f:\n                        json.dump([], f)\n                    wright(f\"Контекст для ветки '{current_branch}' очищен.\")\n\n                # Обработка других команд...\n                elif command in commands['saveCommands']:\n                    backup_file = saveBackup(argument)\n                    wright(f'Backup saved as: {backup_file}')\n                \n                # Другие команды...\n\n            else:\n                response = requestTextAI(res, current_branch)\n                outputText.put(response)\n                wright(response)\n\n            wright('------------')\n```\n\n---\n\n### Шаг 3: Обновление контекстного модуля `content.py`\n\nВ модуле `content.py` нужно убедиться, что функции `save_context` и `load_context` правильно работают с ветками.\n\n```python\ndef save_context(context, branch):\n    # Создаём папку для текущей ветки, если её нет\n    context_dir = os.path.join(BASE_CONTEXT_DIR, branch)\n    os.makedirs(context_dir, exist_ok=True)  # Создаёт папку, если её ещё нет\n    context_file = os.path.join(context_dir, 'context.json')      \n\n    # Сохраняем контекст в файл\n    with open(context_file, 'w', encoding='utf-8') as f:\n        json.dump(context, f, ensure_ascii=False, indent=2)\n\ndef load_context(branch):\n    # Загружаем контекст из соответствующей папки\n    context_file = os.path.join(BASE_CONTEXT_DIR, branch, 'context.json')\n    try:\n        with open(context_file, 'r', encoding='utf-8') as f:      \n            return json.load(f)\n    except FileNotFoundError:\n        return []  # Если файла нет, возвращаем пустой список\n```\n\n---\n\n### Шаг 4: Обновление команды `-branches` для отображения доступных веток\n\nВ файле `show_backups.py` можно добавить функцию для показа доступных веток:\n\n```python\ndef show_branches():\n    branches_dir = \"promts\"\n    if not os.path.exists(branches_dir):\n        wright(\"No branches found. The branches directory does not exist.\")\n        return\n\n    branches = os.listdir(branches_dir)\n    if not branches:\n        wright(\"No branches available.\")\n        return\n\n    wright(\"Available branches:\\n\" + \"\\n\".join(sorted(branches)))\n```\n\nИ в `main.py` добавить её вызов:\n\n```python\nelif command in commands['branchCommands']:\n    show_branches()\n```\n\n---\n\n### Шаг 5: Тестирование\n\n1. Убедитесь, что в папке `promts` есть хотя бы одна ветка (например, `default`).\n2. Запустите программу.\n3. Используйте команду `-branch <имя_ветки>` или `ветка <имя_ветки>` для переключения веток.\n4. Проверьте, что контекст сохраняется и загружается в зависимости от выбранной ветки.\n5. Используйте команду `-branches` для отображения списка доступных веток.\n\n---\n\nПосле этого можно будет переключаться между ветками контекста с помощью текстовых команд."
  },
  {
    "user": "сделай нормальную проверку на то является ли фраза коммандой в main.py",
    "assistant": "To implement a more robust command check in `main.py`, you can enhance the logic that determines whether a phrase is a command. This can be done by creating a function that checks if the input phrase matches any of the defined commands. Here’s how you can do it:\n\n### Step 1: Create a Command Check Function\n\nYou can create a function called `is_command` that checks if the input phrase is a command. This function will take the input phrase and the list of commands as arguments.\n\n```python\ndef is_command(phrase, commands):\n    # Check if the phrase matches any command\n    return phrase in commands or any(phrase.startswith(cmd) for cmd in commands)\n```\n\n### Step 2: Update the Command Check in `main.py`\n\nNow, you can use this function in your main loop to check if the input is a command. Here’s how you can modify the relevant part of your `main` function:\n\n```python\ndef main(queue, outputText, commandToSound, condition):\n    current_branch = \"default\"\n    while not condition.is_set():\n        req = requestInFile()\n        if queue.empty() and not req:\n            time.sleep(1)\n        else:\n            if req:\n                res = req\n            else:\n                res = queue.get()\n            wright(res)\n\n            # Check if the input is a command\n            firstWord = res.split(' ', 1)[0]\n            if is_command(res, allCommands):\n                command = firstWord\n                argument = res.split(' ', 1)[1] if ' ' in res else None\n\n                # Command logic\n                if command in commands['muteCommands']:\n                    wright('stop')\n                    commandToSound.put('stop')\n                elif command in commands['voiceCommands']:\n                    wright('MUTE')\n                    commandToSound.put('-mute')\n                # Add other command checks here...\n                elif command in commands['selectBranchCommands']:\n                    if argument:\n                        current_branch = argument\n                        wright(f\"Текущая ветка изменена на: {current_branch}\")\n                    else:\n                        wright(\"Ошибка: укажите имя ветки для переключения.\")\n                # Continue with other command checks...\n            else:\n                # Handle non-command input\n                response = requestTextAI(res, current_branch)\n                outputText.put(response)\n                wright(response)\n            wright('------------')\n```\n\n### Step 3: Testing\n\n1. Ensure that your command lists (`allCommands`, `commands`) are properly defined and include all the commands you want to check against.\n2. Run your program and test various inputs to see if the command detection works as expected.\n\n### Benefits\n\n- This approach makes your command checking more flexible and maintainable.\n- It allows for partial matches (e.g., commands that start with a certain prefix) if you decide to implement that in the future.\n- It keeps your main loop cleaner and easier to read.\n\nFeel free to adjust the logic in the `is_command` function based on your specific requirements! If you have any further questions or need more assistance, just let me know!"
  },
  {
    "user": "на русском",
    "assistant": "Для улучшения проверки на то, является ли введённая фраза командой в `main.py`, можно сделать это следующим образом:\n\n---\n\n### Шаг 1: Создать функцию для проверки команды\n\nСоздайте функцию `is_command`, которая будет проверять, является ли фраза командой. Эта функция принимает фразу и список команд, а затем возвращает `True`, если фраза совпадает с одной из команд или начинается с одной из них (это полезно для команд с аргументами).\n\n```python\ndef is_command(phrase, commands):\n    # Проверяем, совпадает ли фраза с одной из команд\n    return phrase in commands or any(phrase.startswith(cmd + \" \") for cmd in commands)\n```\n\n---\n\n### Шаг 2: Обновить проверку команды в `main.py`\n\nТеперь в главной функции `main` замените логику проверки команд на использование этой функции. Вот обновлённый код:\n\n```python\ndef main(queue, outputText, commandToSound, condition):\n    current_branch = \"default\"  # Текущая ветка\n    while not condition.is_set():\n        req = requestInFile()\n        if queue.empty() and not req:\n            time.sleep(1)\n        else:\n            if req:\n                res = req\n            else:\n                res = queue.get()\n            wright(res)  # Записываем запрос в файл\n\n            # Проверяем, является ли ввод командой\n            if is_command(res, allCommands):\n                command = res.split(' ', 1)[0]  # Получаем первую часть как команду\n                argument = res.split(' ', 1)[1] if ' ' in res else None  # Получаем аргумент, если он есть\n\n                # Логика выполнения команды\n                if command in commands['muteCommands']:\n                    wright('stop')\n                    commandToSound.put('stop')\n                elif command in commands['voiceCommands']:\n                    wright('MUTE')\n                    commandToSound.put('-mute')\n                elif command in commands['clearCommands']:\n                    clearFile()\n                    continue\n                elif command in commands['selectBranchCommands']:\n                    if argument:\n                        current_branch = argument\n                        wright(f\"Текущая ветка изменена на: {current_branch}\")\n                    else:\n                        wright(\"Ошибка: укажите имя ветки для переключения.\")\n                elif command in commands['helpCommands']:\n                    text_help = text_commands_help()\n                    outputText.put(text_help)\n                elif command in commands['exitCommands']:\n                    condition.set()\n                # Добавьте сюда другие команды...\n            else:\n                # Если фраза не является командой, обрабатываем её как обычный текст\n                response = requestTextAI(res, current_branch)\n                outputText.put(response)\n                wright(response)\n\n            wright('------------')  # Разделитель для удобства\n```\n\n---\n\n### Шаг 3: Тестирование\n\n1. Убедитесь, что список команд (`allCommands` и `commands`) содержит все доступные команды.\n2. Запустите программу.\n3. Введите разные команды и текстовые запросы, чтобы проверить, правильно ли они обрабатываются.\n\n---\n\n### Преимущества\n\n1. **Улучшенная читаемость**: Вынесенная функция `is_command` делает код более понятным и лёгким для чтения.\n2. **Гибкость**: Функция поддерживает как точные совпадения, так и команды с аргументами.\n3. **Простота добавления новых команд**: Для добавления новых команд нужно просто обновить список в `devolp_config.json`.\n\n---\n\n### Пример работы функции `is_command`\n\nЕсли у вас есть команды:\n\n```json\n\"muteCommands\": [\"тихо\", \"хватит\", \"стоп\"],\n\"selectBranchCommands\": [\"-branch\", \"ветка\", \"выбери ветку\"]\n```\n\nТогда:\n\n```python\nprint(is_command(\"тихо\", commands['muteCommands']))  # True\nprint(is_command(\"ветка новая_ветка\", commands['selectBranchCommands']))  # True\nprint(is_command(\"неизвестная команда\", commands['muteCommands']))  # False\n```\n\n---\n\nЕсли что-то непонятно или нужно доработать, дайте знать!"
  },
  {
    "user": "если команда из нескольких слов, то она не выполняется",
    "assistant": "Если команда состоит из нескольких слов (например, \"выбери ветку\"), то нужно добавить обработку для таких случаев. В текущей реализации у вас проверяется только первое слово команды (`firstWord`), что вызывает проблемы с многословными командами.\n\nДавайте исправим это.\n\n---\n\n### Шаг 1: Изменить функцию `is_command`\n\nНужно учесть, что команда может состоять из нескольких слов. В этом случае проверять нужно не только точное совпадение, но и наличие команды в начале строки. Обновим функцию:\n\n```python\ndef is_command(phrase, commands):\n    # Проверяем, является ли фраза точным совпадением или начинается с команды\n    return any(phrase.startswith(cmd) for cmd in commands)\n```\n\nТеперь функция будет возвращать `True`, если фраза начинается с любой команды из списка.\n\n---\n\n### Шаг 2: Обновить логику в `main.py`\n\nТеперь, когда мы можем корректно определять команды из нескольких слов, нужно учитывать команды с аргументами. Обновлённый код:\n\n```python\ndef main(queue, outputText, commandToSound, condition):\n    current_branch = \"default\"  # Текущая ветка\n    while not condition.is_set():\n        req = requestInFile()\n        if queue.empty() and not req:\n            time.sleep(1)\n        else:\n            if req:\n                res = req\n            else:\n                res = queue.get()\n            wright(res)  # Записываем запрос в файл\n\n            # Проверяем, является ли ввод командой\n            command = None\n            argument = None\n\n            for cmd_group in commands.values():\n                if is_command(res, cmd_group):\n                    command = next(cmd for cmd in cmd_group if res.startswith(cmd))\n                    argument = res[len(command):].strip()  # Получаем аргумент, если он есть\n                    break\n\n            if command:\n                # Логика выполнения команды\n                if command in commands['muteCommands']:\n                    wright('stop')\n                    commandToSound.put('stop')\n                elif command in commands['voiceCommands']:\n                    wright('MUTE')\n                    commandToSound.put('-mute')\n                elif command in commands['clearCommands']:\n                    clearFile()\n                    continue\n                elif command in commands['selectBranchCommands']:\n                    if argument:\n                        current_branch = argument\n                        wright(f\"Текущая ветка изменена на: {current_branch}\")\n                    else:\n                        wright(\"Ошибка: укажите имя ветки для переключения.\")\n                elif command in commands['helpCommands']:\n                    text_help = text_commands_help()\n                    outputText.put(text_help)\n                elif command in commands['exitCommands']:\n                    condition.set()\n                # Добавьте сюда другие команды...\n            else:\n                # Если фраза не является командой, обрабатываем её как обычный текст\n                response = requestTextAI(res, current_branch)\n                outputText.put(response)\n                wright(response)\n\n            wright('------------')  # Разделитель для удобства\n```\n\n---\n\n### Что изменилось?\n\n1. **Цикл проверки команд**:\n   Мы перебираем все группы команд (`commands.values()`) и ищем соответствие с помощью `is_command`. Если команда найдена, мы сохраняем её как `command`, а всё остальное после команды — как `argument`.\n\n2. **Обработка аргументов**:\n   Если команда найдена, строка после команды (`res[len(command):].strip()`) становится аргументом. Это особенно важно для команд вроде `выбери ветку новая_ветка`.\n\n3. **Многословные команды**:\n   Теперь `is_command` корректно работает с командами из нескольких слов.\n\n---\n\n### Шаг 3: Тестирование\n\nДопустим, у вас в `devolp_config.json` есть такие команды:\n\n```json\n\"selectBranchCommands\": [\"-branch\", \"ветка\", \"выбери ветку\"]\n```\n\nТестовые случаи:\n\n1. **Ввод**: `выбери ветку новая_ветка`  \n   **Результат**: `current_branch` изменится на `новая_ветка`.\n\n2. **Ввод**: `ветка default`  \n   **Результат**: `current_branch` изменится на `default`.\n\n3. **Ввод**: `ветка`  \n   **Результат**: Выводится ошибка: `Ошибка: укажите имя ветки для переключения.`\n\n---\n\n### Пример работы\n\nДля команды `выбери ветку новая_ветка`:\n\n1. `is_command(\"выбери ветку новая_ветка\", commands['selectBranchCommands'])` вернёт `True`.\n2. `command` будет `\"выбери ветку\"`.\n3. `argument` будет `\"новая_ветка\"`.\n4. Переключение ветки будет выполнено.\n\n---\n\n### Преимущества\n\n- Теперь команды из нескольких слов корректно обрабатываются.\n- Аргументы команд автоматически извлекаются из строки.\n- Код стал более читаемым и легко расширяемым.\n\nЕсли есть дополнительные вопросы или нужно что-то уточнить, дайте знать! 😊"
  },
  {
    "user": "добавь возможность ставить таймер",
    "assistant": "Для добавления функциональности таймера в вашу программу нужно:\n\n1. Создать обработку команды таймера в `main.py`.\n2. Реализовать логику таймера (она у вас уже частично есть в файле `timer.py`).\n3. Добавить обработку аргумента, чтобы пользователь мог указать время для таймера.\n\n---\n\n### Шаг 1: Добавить команду в `devolp_config.json`\n\nДобавьте новую команду для установки таймера в секцию `commands`:\n\n```json\n\"setTimerCommands\": [\"-timer\", \"поставь таймер\", \"таймер\"]\n```\n\n---\n\n### Шаг 2: Обновить обработку команд в `main.py`\n\nДобавьте обработку команды таймера в функции `main`. \n\n```python\nimport threading\nfrom app.customCommands.timer import timer\n\ndef main(queue, outputText, commandToSound, condition):\n    current_branch = \"default\"\n    active_timer = None  # Переменная для хранения состояния таймера (если таймер запущен)\n    timer_stop_event = threading.Event()  # Событие для остановки таймера\n\n    while not condition.is_set():\n        req = requestInFile()\n        if queue.empty() and not req:\n            time.sleep(1)\n        else:\n            if req:\n                res = req\n            else:\n                res = queue.get()\n            wright(res)\n\n            # Проверяем, является ли ввод командой\n            command = None\n            argument = None\n\n            for cmd_group in commands.values():\n                if is_command(res, cmd_group):\n                    command = next(cmd for cmd in cmd_group if res.startswith(cmd))\n                    argument = res[len(command):].strip()  # Получаем аргумент, если он есть\n                    break\n\n            if command:\n                # Логика выполнения команды\n                if command in commands['setTimerCommands']:\n                    if argument and argument.isdigit():  # Проверяем, что аргумент — число\n                        timer_seconds = int(argument)\n                        if active_timer:  # Если таймер уже работает, сначала его остановим\n                            timer_stop_event.set()\n                            active_timer.join()\n                            timer_stop_event.clear()\n                        wright(f\"Таймер установлен на {timer_seconds} секунд.\")\n                        active_timer = threading.Thread(target=timer, args=(timer_seconds, timer_stop_event), daemon=True)\n                        active_timer.start()\n                    else:\n                        wright(\"Ошибка: укажите время в секундах для таймера.\")\n                elif command in commands['clearCommands']:\n                    clearFile()\n                    continue\n                elif command in commands['exitCommands']:\n                    condition.set()\n                # Добавьте сюда другие команды...\n            else:\n                # Если фраза не является командой, обрабатываем её как обычный текст\n                response = requestTextAI(res, current_branch)\n                outputText.put(response)\n                wright(response)\n\n            wright('------------')  # Разделитель для удобства\n```\n\n---\n\n### Шаг 3: Реализовать логику таймера в `timer.py`\n\nУ вас уже есть реализация таймера в `timer.py`. Давайте её немного подправим, чтобы она поддерживала остановку через `Event`.\n\n```python\nimport time\nimport json\nfrom app.utils.playSound import playSound\n\nwith open('devolp_config.json', 'r', encoding='utf-8') as file:\n    devolp_config = json.load(file)\n    timerSound = devolp_config['timerSound']\n\ndef timer(seconds, stop_event):\n    start_time = time.time()\n    while not stop_event.is_set() and (time.time() - start_time < seconds):\n        time.sleep(1)\n    if not stop_event.is_set():  # Если таймер не был остановлен\n        playSound(timerSound)\n        print(\"⏰ Таймер завершён!\")\n```\n\n---\n\n### Шаг 4: Добавить звуковой файл для таймера\n\nУбедитесь, что звуковой файл для таймера указан в `devolp_config.json`:\n\n```json\n\"timerSound\": \"sounds/timer.mp3\"\n```\n\nИ добавьте файл `timer.mp3` в папку `sounds`.\n\n---\n\n### Шаг 5: Тестирование\n\nПопробуйте следующие команды:\n\n1. **Установка таймера**:\n   ```\n   таймер 10\n   ```\n   Результат: Таймер начнёт отсчёт 10 секунд и проиграет звук по завершении.\n\n2. **Повторная установка таймера**:\n   ```\n   таймер 5\n   ```\n   Результат: Если таймер уже работал, он остановится и начнётся новый отсчёт.\n\n3. **Неправильный ввод**:\n   ```\n   таймер abc\n   ```\n   Результат: Сообщение об ошибке: \"Ошибка: укажите время в секундах для таймера.\"\n\n---\n\n### Шаг 6: Обработка остановки программы\n\nПри выходе из программы или завершении работы, убедитесь, что таймер корректно остановлен:\n\n```python\nif active_timer:\n    timer_stop_event.set()\n    active_timer.join()\n```\n\nДобавьте это в конец функции `main`, перед завершением цикла.\n\n---\n\nТеперь ваш бот поддерживает установку таймера и его управление. Если нужно что-то уточнить или доработать, дайте знать! 😊"
  },
  {
    "user": "таймер должен останавливаться только командой",
    "assistant": "To ensure that the timer can only be stopped by a specific command, you can modify the existing timer logic in your `main.py` file. Here’s how to implement this functionality:\n\n### Step 1: Update the Command List\nFirst, add a command for stopping the timer in your `devolp_config.json` file. For example:\n\n```json\n\"stopTimerCommands\": [\"-stop-timer\", \"останови таймер\"]\n```\n\n### Step 2: Modify the Timer Logic in `main.py`\nNext, update the `main` function to handle the stopping of the timer with the new command. Here’s how you can do it:\n\n```python\nimport threading\nfrom app.customCommands.timer import timer\n\ndef main(queue, outputText, commandToSound, condition):\n    current_branch = \"default\"\n    active_timer = None\n    timer_stop_event = threading.Event()  # Event to stop the timer\n\n    while not condition.is_set():\n        req = requestInFile()\n        if queue.empty() and not req:\n            time.sleep(1)\n        else:\n            if req:\n                res = req\n            else:\n                res = queue.get()\n            wright(res)\n\n            command = None\n            argument = None\n            for cmd_group in commands.values():\n                if is_command(res, cmd_group):\n                    command = next(cmd for cmd in cmd_group if res.startswith(cmd))\n                    argument = res[len(command):].strip()  # Get the argument if it exists\n                    break\n\n            if command:\n                # Timer command logic\n                if command in commands['setTimerCommands']:\n                    if argument and argument.isdigit():\n                        timer_seconds = int(argument)\n                        if active_timer:  # If the timer is already running, stop it\n                            timer_stop_event.set()\n                            active_timer.join()  # Wait for the timer thread to finish\n                        timer_stop_event.clear()  # Reset the stop event\n                        wright(f\"Таймер установлен на {timer_seconds} секунд.\")\n                        active_timer = threading.Thread(target=timer, args=(timer_seconds, timer_stop_event), daemon=True)\n                        active_timer.start()\n                    else:\n                        wright(\"Ошибка: укажите время в секундах для таймера.\")\n\n                elif command in commands['stopTimerCommands']:\n                    if active_timer:  # Only stop if the timer is running\n                        timer_stop_event.set()  # Signal the timer to stop\n                        active_timer.join()  # Wait for the timer thread to finish\n                        wright(\"Таймер остановлен.\")\n                    else:\n                        wright(\"Таймер не запущен.\")\n\n                # Other command logic...\n                elif command in commands['exitCommands']:\n                    condition.set()  # Exit the loop\n\n                else:\n                    # Handle non-command input\n                    response = requestTextAI(res, current_branch)\n                    outputText.put(response)\n                    wright(response)\n                    wright('------------')  # Separator for clarity\n```\n\n### Step 3: Update the Timer Logic in `timer.py`\nEnsure that your timer logic can handle the stop event correctly. The existing implementation should already support this, but here’s a reminder of how it should look:\n\n```python\nimport time\nfrom app.utils.playSound import playSound\n\ndef timer(seconds, stop_event):\n    start_time = time.time()\n    while not stop_event.is_set() and (time.time() - start_time < seconds):\n        time.sleep(1)\n    if not stop_event.is_set():  # If the timer wasn't stopped\n        playSound(timerSound)\n        print(\"⏰ Таймер завершён!\")\n```\n\n### Step 4: Testing\n1. **Start the Timer**: Use the command `-timer 10` to start a 10-second timer.\n2. **Stop the Timer**: Use the command `-stop-timer` or `останови таймер"
  },
  {
    "user": "делай в папке каждой ветки файл с обшим и очень обязвтельным контекстом для ветки",
    "assistant": "Для реализации обязательного контекста, который будет загружаться из отдельного файла в каждой ветке, можно внести изменения в вашу функцию `load_context` и добавить новую функциональность для загрузки \"обязательного\" контекста. Вот как это можно сделать:\n\n---\n\n### Шаг 1: Обновить структуру папок веток\n\nВ папке каждой ветки (`promts/<branch>`) создайте два файла:\n1. `context.json` — для хранения основного контекста.\n2. `mandatory_context.json` — для хранения обязательного контекста, который всегда загружается.\n\nПример структуры папки:\n```\npromts/\n├── ветка_1/\n│   ├── context.json\n│   ├── mandatory_context.json\n├── ветка_2/\n│   ├── context.json\n│   ├── mandatory_context.json\n```\n\n---\n\n### Шаг 2: Обновить функцию `load_context`\n\nИзмените функцию `load_context`, чтобы она загружала обязательный контекст из файла `mandatory_context.json` и объединяла его с основным контекстом.\n\n```python\ndef load_context(branch):\n    # Загружаем основной контекст\n    context_file = os.path.join(BASE_CONTEXT_DIR, branch, 'context.json')\n    mandatory_context_file = os.path.join(BASE_CONTEXT_DIR, branch, 'mandatory_context.json')\n    \n    try:\n        with open(context_file, 'r', encoding='utf-8') as f:\n            context = json.load(f)\n    except FileNotFoundError:\n        context = []  # Если файла нет, возвращаем пустой список\n    \n    # Загружаем обязательный контекст\n    mandatory_context = []\n    try:\n        with open(mandatory_context_file, 'r', encoding='utf-8') as f:\n            mandatory_context = json.load(f)\n    except FileNotFoundError:\n        pass  # Если файла нет, просто игнорируем\n\n    # Объединяем обязательный контекст с основным\n    return mandatory_context + context\n```\n\n---\n\n### Шаг 3: Обновить функцию `save_context`\n\nПри сохранении нового контекста в файл `context.json`, файл `mandatory_context.json` не должен изменяться. Функция `save_context` остаётся без изменений:\n\n```python\ndef save_context(context, branch):\n    # Создаём папку для текущей ветки, если её нет\n    context_dir = os.path.join(BASE_CONTEXT_DIR, branch)\n    os.makedirs(context_dir, exist_ok=True)  # Создаёт папку, если её ещё нет\n    context_file = os.path.join(context_dir, 'context.json')      \n\n    # Сохраняем контекст в файл\n    with open(context_file, 'w', encoding='utf-8') as f:\n        json.dump(context, f, ensure_ascii=False, indent=2)       \n```\n\n---\n\n### Шаг 4: Убедиться, что обязательный контекст загружается в `requestTextAI`\n\nОбновите функцию `requestTextAI`, чтобы она использовала объединённый контекст из `load_context`:\n\n```python\ndef requestTextAI(request, branch, fastMode=False, precise=False): \n    wright(f'request: {request}', log=True)\n    wright('*Loading...*')\n\n    models = [\"gpt-4\", \"phi-4\", \"llama-3.3-70b\", \"gemini-1.5-flash\", \"gpt-4o\"]\n    content =''\n    \n    if fastMode:\n        models = [\"gpt-4o-mini\", \"gemini-1.5-flash\"]\n    if precise:\n        content = 'точный компьютер, который отвечает только по делу'\n\n    context = load_context(branch)  # Загружаем объединённый контекст (с обязательным)\n    if branch == 'code_editing':\n        code_context = load_code_files()\n        messages = [\n            {\"role\": \"system\", \"content\": \"Ты опытный программист, анализируй код и помогай с ним. Отвечай на русском\"},\n            {\"role\": \"system\", \"content\": code_context}\n        ]\n    else:\n        messages = [{\"role\": \"system\", \"content\": content}]\n        \n    for msg in context[-MAX_CONTEXT_LENGTH:]:\n        messages.append({\"role\": \"user\", \"content\": msg[\"user\"]}) \n        messages.append({\"role\": \"assistant\", \"content\": msg[\"assistant\"]})\n    messages.append({\"role\": \"user\", \"content\": request})\n\n    for model in models:\n        try:\n            response = client.chat.completions.create(\n                model=model,\n                messages=messages,\n                web_search=False,\n                temperature=0.7,\n            )\n            response_text = response.choices[0].message.content   \n\n            context.append({\n                \"user\": request,\n                \"assistant\": response_text\n            })\n            save_context(context, branch)\n\n            return response_text\n        except:\n            wright('Ошибка получения ответа', log=True)\n            pass\n```\n\n---\n\n### Шаг 5: Тестирование\n\n1. Создайте файл `mandatory_context.json` для каждой ветки. Например:\n   ```json\n   [\n       {\"role\": \"system\", \"content\": \"Это обязательный контекст для ветки.\"},\n       {\"role\": \"system\", \"content\": \"Данный контекст должен загружаться всегда.\"}\n   ]\n   ```\n\n2. Убедитесь, что при использовании ветки обязательный контекст всегда включён в запрос.\n\n---\n\n### Пример работы\n\nЕсли у вас есть:\n\n- `mandatory_context.json`:\n   ```json\n   [\n       {\"role\": \"system\", \"content\": \"Это обязательный контекст для ветки.\"}\n   ]\n   ```\n- `context.json`:\n   ```json\n   [\n       {\"user\": \"Привет!\", \"assistant\": \"Здравствуйте!\"}\n   ]\n   ```\n\nТо результат работы функции `load_context('example_branch')` будет:\n\n```json\n[\n    {\"role\": \"system\", \"content\": \"Это обязательный контекст для ветки.\"},\n    {\"user\": \"Привет!\", \"assistant\": \"Здравствуйте!\"}\n]\n```\n\n---\n\nТеперь обязательный контекст всегда будет загружаться для каждой ветки, и он останется неизменным. Если нужно что-то доработать, дайте знать! 😊"
  }
]